package io.github.isagroup.services.jwt;

import java.util.Date;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import io.github.isagroup.PricingContext;
import io.github.isagroup.PricingEvaluatorUtil;
import io.jsonwebtoken.JwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.UnsupportedJwtException;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;

/**
 * Utility class that provides methods to generate and manage JWT.
 */
@Component
public class PricingJwtUtils {

    @Autowired
    private PricingContext pricingContext;

    public PricingJwtUtils(PricingContext pricingContext) {
        this.pricingContext = pricingContext;
    }

    private static final Logger LOGGER = LoggerFactory.getLogger(PricingJwtUtils.class);

    /**
     * Given a map claims and subject creates a JWT token given
     * {@link PricingContext} configuation
     * 
     * @param claims  a {@link Map} of claims
     * @param subject a target of the token
     * @return The subject of the JWT
     */
    public String createJwtToken(Map<String, ?> claims, String subject) {

        return Jwts.builder()
                .claims(claims)
                .subject(subject)
                .issuedAt(new Date(System.currentTimeMillis()))
                .expiration(new Date(System.currentTimeMillis() + pricingContext.getJwtExpiration()))
                .signWith(Keys.hmacShaKeyFor(Decoders.BASE64.decode(pricingContext.getJwtSecret())))
                .compact();
    }

    /**
     * Extracts the subject from the given JWT.
     * 
     * @param token a JWT that contains a subject
     * @return The subject of the JWT
     */
    public String getSubjectFromJwtToken(String token) {
        return Jwts.parser().verifyWith(Keys.hmacShaKeyFor(Decoders.BASE64.decode((pricingContext.getJwtSecret()))))
                .build()
                .parseSignedClaims(token).getPayload().getSubject();
    }

    /**
     * Extracts the features from a JWT generated by
     * {@link PricingEvaluatorUtil#generateUserToken()} method
     * 
     * @param token a JWT generated by
     *              {@link PricingEvaluatorUtil#generateUserToken()} method
     * @return A Map that contains the evaluation of all the features for the
     *         current user located in the JWT body
     */
    public Map<String, Map<String, Object>> getFeaturesFromJwtToken(String token) {
        return (Map<String, Map<String, Object>>) Jwts.parser()
                .verifyWith(Keys.hmacShaKeyFor(Decoders.BASE64.decode((pricingContext.getJwtSecret())))).build()
                .parseSignedClaims(token)
                .getPayload().get("features");
    }

    /**
     * Extracts the plan context from a JWT generated by
     * {@link PricingEvaluatorUtil#generateUserToken()} method
     * 
     * @param token a JWT generated by
     *              {@link PricingEvaluatorUtil#generateUserToken()} method
     * @return A Map that contains the plan context used in the evaluation of
     *         features located in the JWT body
     */
    public Map<String, Object> getPlanContextFromJwtToken(String token) {
        return (Map<String, Object>) Jwts.parser()
                .verifyWith(Keys.hmacShaKeyFor(Decoders.BASE64.decode((pricingContext.getJwtSecret())))).build()
                .parseSignedClaims(token)
                .getPayload().get("planContext");
    }

    /**
     * Extracts the user context from a JWT generated by
     * {@link PricingEvaluatorUtil#generateUserToken()} method
     * 
     * @param token a JWT generated by
     *              {@link PricingEvaluatorUtil#generateUserToken()} method
     * @return A Map that contains the user context used in the evaluation of
     *         features located in the JWT body
     */
    public Map<String, Object> getUserContextFromJwtToken(String token) {
        return (Map<String, Object>) Jwts.parser()
                .verifyWith(Keys.hmacShaKeyFor(Decoders.BASE64.decode((pricingContext.getJwtSecret())))).build()
                .parseSignedClaims(token)
                .getPayload().get("userContext");
    }

    /**
     * Validates a JWT
     * It is the equivalent of getting the token's subject
     * 
     * @param authToken a JWT String
     * @return true if the token is correct, false otherwise
     */
    public boolean validateJwtToken(String authToken) {
        try {
            Jwts.parser().verifyWith(Keys.hmacShaKeyFor(Decoders.BASE64.decode((pricingContext.getAuthJwtSecret()))))
                    .build()
                    .parseSignedClaims(authToken);
            return true;
        } catch (UnsupportedJwtException e) {
            LOGGER.error("jwt {} argument does not represent a signed Claims JWT: ", authToken, e);
        } catch (JwtException e) {
            LOGGER.error("jwt {} cannot be parsed or validated as required: ", authToken, e);
        } catch (IllegalArgumentException e) {
            LOGGER.error("Illegal argument for token", e);
        }

        return false;
    }
}
