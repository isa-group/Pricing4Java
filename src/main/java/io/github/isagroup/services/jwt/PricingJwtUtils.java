package io.github.isagroup.services.jwt;

import java.util.Date;
import java.util.Map;

import javax.crypto.SecretKey;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import io.github.isagroup.PricingContext;
import io.github.isagroup.PricingEvaluatorUtil;
import io.jsonwebtoken.JwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.UnsupportedJwtException;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;

/**
 * Utility class that provides methods to generate and manage JWT.
 */
@Component
public class PricingJwtUtils {

    @Autowired
    private PricingContext pricingContext;

    private final SecretKey pricingSecretKey;

    public PricingJwtUtils(PricingContext pricingContext) {
        this.pricingContext = pricingContext;
        this.pricingSecretKey = createKeyForBase64String(pricingContext.getJwtSecret());
    }

    /**
     * Given a base64 encoded {@link String} creates a {@link SecretKey} to be used
     * when signing a JWT token. Given string must meet HMAC-SHA bit length
     * requirements
     *
     * @param base64String
     * @return {@link javax.crypto.SecretKey}
     * @throws {@link io.jsonwebtoken.security.WeakKeyException} if the string is
     *                not strong enough to be used with HMAC-SHA algorithms
     */
    private static SecretKey createKeyForBase64String(String base64String) {
        return Keys.hmacShaKeyFor(Decoders.BASE64.decode(base64String));
    }

    private static final Logger LOGGER = LoggerFactory.getLogger(PricingJwtUtils.class);

    /**
     * Given a map claims and subject creates a JWT token given
     * {@link PricingContext} configuation
     *
     * @param claims  a {@link Map} of claims
     * @param subject a target of the token
     * @return The subject of the JWT
     */
    public String createJwtToken(Map<String, ?> claims, String subject) {

        return Jwts.builder()
                .claims(claims)
                .subject(subject)
                .issuedAt(new Date(System.currentTimeMillis()))
                .expiration(new Date(System.currentTimeMillis() + pricingContext.getJwtExpiration()))
                .signWith(pricingSecretKey)
                .compact();
    }

    /**
     * Extracts the subject from the given JWT.
     * 
     * @param token a JWT that contains a subject
     * @return The subject of the JWT
     */
    public String getSubjectFromJwtToken(String token) {
        return Jwts.parser().verifyWith(pricingSecretKey)
                .build()
                .parseSignedClaims(token).getPayload().getSubject();
    }

    /**
     * Extracts the features from a JWT generated by
     * {@link PricingEvaluatorUtil#generateUserToken()} method
     * 
     * @param token a JWT generated by
     *              {@link PricingEvaluatorUtil#generateUserToken()} method
     * @return A Map that contains the evaluation of all the features for the
     *         current user located in the JWT body
     */
    public Map<String, Map<String, Object>> getFeaturesFromJwtToken(String token) {
        return (Map<String, Map<String, Object>>) Jwts.parser()
                .verifyWith(pricingSecretKey).build()
                .parseSignedClaims(token)
                .getPayload().get("features");
    }

    /**
     * Extracts the plan context from a JWT generated by
     * {@link PricingEvaluatorUtil#generateUserToken()} method
     * 
     * @param token a JWT generated by
     *              {@link PricingEvaluatorUtil#generateUserToken()} method
     * @return A Map that contains the plan context used in the evaluation of
     *         features located in the JWT body
     */
    public Map<String, Object> getPlanContextFromJwtToken(String token) {
        return (Map<String, Object>) Jwts.parser()
                .verifyWith(pricingSecretKey).build()
                .parseSignedClaims(token)
                .getPayload().get("planContext");
    }

    /**
     * Extracts the user context from a JWT generated by
     * {@link PricingEvaluatorUtil#generateUserToken()} method
     * 
     * @param token a JWT generated by
     *              {@link PricingEvaluatorUtil#generateUserToken()} method
     * @return A Map that contains the user context used in the evaluation of
     *         features located in the JWT body
     */
    public Map<String, Object> getUserContextFromJwtToken(String token) {
        return (Map<String, Object>) Jwts.parser()
                .verifyWith(pricingSecretKey).build()
                .parseSignedClaims(token)
                .getPayload().get("userContext");
    }

    /**
     * Validates a JWT
     * It is the equivalent of getting the token's subject
     * 
     * @param authToken a JWT String
     * @return true if the token is correct, false otherwise
     */
    public boolean validateJwtToken(String authToken) {
        try {
            Jwts.parser().verifyWith(createKeyForBase64String(pricingContext.getAuthJwtSecret()))
                    .build()
                    .parseSignedClaims(authToken);
            return true;
        } catch (UnsupportedJwtException e) {
            LOGGER.error("jwt {} argument does not represent a signed Claims JWT: ", authToken, e);
        } catch (JwtException e) {
            LOGGER.error("jwt {} cannot be parsed or validated as required: ", authToken, e);
        } catch (IllegalArgumentException e) {
            LOGGER.error("Illegal argument for token", e);
        }

        return false;
    }
}
